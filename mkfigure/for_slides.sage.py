

# This file was *autogenerated* from the file mkfigure/for_slides.sage
from sage.all_cmdline import *   # import sage library

_sage_const_125 = Integer(125); _sage_const_144 = Integer(144); _sage_const_16 = Integer(16); _sage_const_8 = Integer(8); _sage_const_0p4 = RealNumber('0.4'); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0p3 = RealNumber('0.3'); _sage_const_1en6 = RealNumber('1e-6'); _sage_const_5 = Integer(5); _sage_const_1p3 = RealNumber('1.3'); _sage_const_1p999 = RealNumber('1.999'); _sage_const_2p00001 = RealNumber('2.00001')
rows = _sage_const_125 
cols = _sage_const_144 
beta = _sage_const_16 
aug = _sage_const_8 
hi = int(rows*_sage_const_0p4 )

set_random_seed(_sage_const_0 )
def pgmify(m,filename,malt=None):
    r,c = m.dimensions()
    g = _sage_const_7 
    with open(filename,"w") as f:
        f.write("P2 %d %d %d\n" % (c,r,g))
        for i in range(r):
            alt_seen = False
            m_seen = False
            for j in range(c):
                level = g - g*int(m[i,j])
                if malt is not None:
                    alt_seen = alt_seen or malt[i,j]
                    m_seen   = m_seen   or m[i,j]
                if alt_seen and not m_seen:
                    level = g-_sage_const_1 
                f.write("%d " % level)
            f.write("\n")

def ppm_highlight(m,filename,hi=None,pad=_sage_const_1 ,inner=_sage_const_4 ,outer=_sage_const_1 ,aug=aug,hspread=True):
    r,c = m.dimensions()
    if hi is None: hi=int(r*_sage_const_0p4 )
    g = _sage_const_7 
    ser = [[(g,g,g)]*(c+_sage_const_2 *(inner+outer+pad)) for _ in range(r)]
    for i in range(r):
        for j in range(c):
            h = g//_sage_const_2  + (g-g//_sage_const_2 )*int(_sage_const_1 -m[i,j])
            ser[i][j+pad+inner+outer] = (h,h,h)
    
    # white inner border
    for i in range(inner+pad+_sage_const_1 ):
        for j in range(outer,c+_sage_const_2 *inner+_sage_const_2 *pad):
            ser[hi+i][j] = ser[hi-i][j] = (g,g,g)

    # red outer border
    for i in range(inner+pad+_sage_const_1 ,inner+pad+outer+_sage_const_1 ):
        for j in range(_sage_const_0 ,len(ser[_sage_const_0 ])):
            ser[hi+i][j] = ser[hi-i][j] = (g,_sage_const_0 ,_sage_const_0 )
    for i in range(-inner-pad-outer,inner+pad+outer+_sage_const_1 ):
        for j in range(outer):
            ser[hi+i][j] = ser[hi+i][len(ser[_sage_const_0 ])-_sage_const_1 -j] = (g,_sage_const_0 ,_sage_const_0 )

    for j in range(c):
        if m[hi,j]:
            for a in range(-inner,_sage_const_1 +inner):
                rg = _sage_const_0 
                if j >= c-aug:
                    rg = _sage_const_0 
                    color = (_sage_const_0 ,_sage_const_2 *g//_sage_const_3 ,g//_sage_const_3 )
                elif hspread:
                    #rg = inner
                    color = (_sage_const_0 ,_sage_const_0 ,g)
                else:
                    rg = _sage_const_0 
                    color = (_sage_const_0 ,_sage_const_0 ,g)
                for b in range(-rg,_sage_const_1 +rg):
                    if a**_sage_const_2  + b**_sage_const_2  <= (inner+_sage_const_0p3 )**_sage_const_2 :
                        ser[hi+a][j+b+inner+pad+outer] = color

    with open(filename,"w") as f:
        f.write("P3 %d %d %d\n" % (len(ser[_sage_const_0 ]),len(ser),g))
        for row in ser:
            for color in row:
                f.write("%d %d %d " % color)
            f.write("\n")

def ref(m,aug=aug):
    r,c = m.dimensions()
    e = _sage_const_0 
    for j in range(c-aug):
        for i in range(e,r):
            if m[i,j]:
                m.swap_rows(i,e)
                for ii in range(e+_sage_const_1 ,r):
                    for jj in range(j+_sage_const_1 ,c):
                        m[ii,jj] += m[ii,j]*m[e,jj]
                    m[ii,j] = _sage_const_0 
                e += _sage_const_1 
                break
    return m

def peel(m):
    # obviously not the real peeling algorithm: n^3 and returns the same result
    r,c = m.dimensions()
    e = _sage_const_0 
    while e<r and e<c:
        for j in range(e,c):
            seen = None
            for i in range(e,r):
                if m[i,j]:
                    if seen is not None:
                        seen = None # can't peel
                        break
                    else: seen = i
            if seen is not None:
                m.swap_rows(seen,e)
                m.swap_columns(j,e)
                break
        e += _sage_const_1 
    return m

def ribbon_matrix(rows,cols,beta,aug):
    m = Matrix(GF(_sage_const_2 ),rows,cols+aug)
    for i in range(rows):
        start = randint(_sage_const_0 ,cols-beta)
        m[i,start]=_sage_const_1 
        for j in range(beta):
            m[i,start+_sage_const_1 +j] = randint(_sage_const_0 ,_sage_const_1 )
        for k in range(aug):
            m[i,cols+k] = randint(_sage_const_0 ,_sage_const_1 )
    return m

def hamming_matrix(rows,cols,wt,aug):
    m = Matrix(GF(_sage_const_2 ),rows,cols+aug)
    for i in range(rows):
        w = _sage_const_0 
        while w < wt:
            j = randint(_sage_const_0 ,cols-_sage_const_1 )
            if m[i,j] == _sage_const_0 : w+=_sage_const_1 
            m[i,j] = _sage_const_1 
        for k in range(aug):
            m[i,cols+k] = randint(_sage_const_0 ,_sage_const_1 )
    return m

def frayed_ribbon_matrix(rows,cols,beta,aug,k=_sage_const_1 ,force_stride=(hi,_sage_const_2 )):
    beta = beta//_sage_const_2 
    cols += (-cols) % beta
    blocks = cols//beta
    m = Matrix(GF(_sage_const_2 ),rows,cols+aug)
    k *= ln(blocks) / beta
    for i in range(rows):
        a = randint(_sage_const_0 ,blocks-_sage_const_1 )
        stride = int(k/max(_sage_const_1en6 ,random()**_sage_const_2 ))
        if i==force_stride[_sage_const_0 ]: stride=force_stride[_sage_const_1 ] # for the diagram
        b = (a+stride) % blocks
        if a==b: b = (b+_sage_const_1 ) % blocks
        for j in range(beta):
            m[i,a*beta+j] = randint(_sage_const_0 ,_sage_const_1 )
            m[i,b*beta+j] = randint(_sage_const_0 ,_sage_const_1 )
        for j in range(aug):
            m[i,cols+j] = randint(_sage_const_0 ,_sage_const_1 )
    return m
    

m = ribbon_matrix(rows,cols,beta,aug)
ppm_highlight(m,"figure/ribbon_highlight.ppm",hspread=False)
pgmify(m,"figure/ribbon_unsorted.pgm")
m = Matrix(GF(_sage_const_2 ), rows,cols+aug, list(sorted(m.rows(),key=lambda r:str(r),reverse=True)))
pgmify(m,"figure/ribbon_sorted.pgm")
mm = ref(copy(m))
pgmify(mm,"figure/ribbon_ref.pgm")

m = hamming_matrix(rows,cols,_sage_const_5 ,aug)
pgmify(m,"figure/hamming_unsorted.pgm")
ppm_highlight(m,"figure/hamming_highlight.ppm")
mm = ref(copy(m))
pgmify(mm,"figure/hamming_ref.pgm")

m = hamming_matrix(rows,int(rows*_sage_const_1p3 ),_sage_const_3 ,aug)
pgmify(m,"figure/peel_unsorted.pgm")
ppm_highlight(m,"figure/peel_hilight.ppm")
mm = peel(copy(m))
pgmify(mm,"figure/peel_ref.pgm")

def frayed_blocks(row,beta,aug):
    beta = beta//_sage_const_2 
    blocks = (len(row)-aug)//beta
    s = set()
    for i in range(blocks):
        for j in range(beta):
            if row[i*beta+j]:
                s.add(i)
                break
    assert len(s) == _sage_const_2 
    a,b = s
    return (min(a,b),max(a,b),blocks)

def frayed_key(beta,aug):
    def fn(row):
        a,b,blocks = frayed_blocks(row,beta,aug)
        if (a+blocks-b) < (b-a): a,b = b,a
        return a,-((b-a)%blocks)
    return fn

def frayed_key2(beta,aug):
    def fn(row):
        a,b,blocks = frayed_blocks(row,beta,aug)
        if (a+blocks-b) < (b-a): a,b = b,a
        xorstride = int(floor(log(a^b,_sage_const_1p999 )))
        ret =  xorstride,min(a,b)//(_sage_const_2 **xorstride),a,b
        return ret
    return fn



def ref_frayed(m,m_orig,beta=beta,aug=aug,stage=_sage_const_0 ,red=False):
    r,c = m.dimensions()
    inscope = set([i for i in range(r)
            for (a,b,_) in [frayed_blocks(m_orig[i],beta,aug)]
            if a^b <= _sage_const_2 **stage])
    inscope_max = max(*inscope)
    inscope_prev = set([i for i in range(r)
            for (a,b,_) in [frayed_blocks(m_orig[i],beta,aug)]
            if a^b <= _sage_const_2 **(stage-_sage_const_1 )])
    e = inscope_min = max(*(list(inscope_prev)+[-_sage_const_1 ,-_sage_const_1 ]))+_sage_const_1 
    for j in range(c-aug):
        for i in range(e,inscope_max+_sage_const_1 ):
            if m[i,j]:
                m.swap_rows(i,e)
                for ii in range(e+_sage_const_1 ,r if red else inscope_max+_sage_const_1 ):
                    for jj in range(j+_sage_const_1 ,c):
                        m[ii,jj] += m[ii,j]*m[e,jj]
                    m[ii,j] = _sage_const_0 
                e += _sage_const_1 
                break

    def not_in_echelon(cc):
        if cc >= c-aug: return True,cc
        for i in range(inscope_max,-_sage_const_1 ,-_sage_const_1 ):
            if m[i,cc]:
                for j in range(cc):
                    if m[i,j]: return True,cc # not in echelon
                return False,cc # in echelon
        return True,cc

    # if red:
    #     perm = list(sorted(list(range(c)),key=not_in_echelon))
    #     m.permute_columns(Permutation([i+1 for i in perm]))

    return m

cols = rows
m = frayed_ribbon_matrix(rows,cols,beta,aug)
pgmify(m,"figure/frayed_unsorted.pgm")
ppm_highlight(m,"figure/frayed_hilight.ppm")
m = Matrix(GF(_sage_const_2 ), rows, m.dimensions()[_sage_const_1 ], list(sorted(m.rows(),key=frayed_key(beta,aug))))
pgmify(m,"figure/frayed_sorted.pgm")
m = Matrix(GF(_sage_const_2 ), rows, m.dimensions()[_sage_const_1 ], list(sorted(m.rows(),key=frayed_key2(beta,aug))))
pgmify(m,"figure/frayed_sorted_hier.pgm")
mm = copy(m)
for scope in range(int(ceil(log(ceil(cols/beta),_sage_const_2p00001 )))+_sage_const_2 ):
    ref_frayed(mm,m,beta,aug,scope,False)
    pgmify(mm,"figure/frayed_sorted_ref_%d.0.pgm" % scope)
    ref_frayed(mm,m,beta,aug,scope,True)
    pgmify(mm,"figure/frayed_sorted_ref_%d.1.pgm" % scope)

